## JavaScript 나올 만한 질문들

순서는 중요도와 관계 없음

>1. let과 const가 도입 된 이유 (var, let, const 차이)

  - 기존(ES5까지)에는 var 키워드를 사용하여 변수를 선언했으나, var 키워드를 사용할 경우 **변수의 중복선언 가능, 함수 레벨 스코프 지원, 변수 호이스팅**의 문제가 있다. 
  여기서 **변수의 중복 선언**은 말 그대로 이미 선언된 변수가 있음에도 동일한 식별자를 가지는 변수를 선언할 수 있음을 의미하고 이는 네임스페이스 오염의 문제가 있다.
  **함수 레벨 스코프**는 var로 선언 된 변수는 함수의 코드 블록 {} 만을 지역 스코프로 인정하는 것을 의미한다. 즉, if문, for문 등의 코드 블록 내부에서 변수를 선언할 경우 이는 모두 전역 변수가 된다.
  **변수 호이스팅**은 var로 선언된 변수는 런타임 이전에 소스 코드 평가 과정에서 undefined로 초기화 되므로 변수 선언 이전에 참조가 가능한 현상을 말한다. 
  이러한 문제를 해결하기 위해 ES6부터 let과 const가 도입되었고, let과 const는 변수의 중복 선언을 막고, 블록 레벨 스코프를 지원하며, 런타임에 변수의 초기화가 이루어지므로 변수 호이스팅이 발생하지 않는 것 처럼 동작된다는 장점이 있다. (참고로 호이스팅이 발생하지 않는 것은 아니다.)

>2. 깊은 복사와 얕은 복사에 대한 설명

  - 객체를 프로퍼티로 갖는 객체, 즉 중첩 객체를 복사할 때 한 단계만 복사 되는 것을 얕은 복사, 내부의 중첩 객체까지 모두 복사 되는 것을 깊은 복사라 한다.
  깊은 복사를 위해서는 객체의 내부 프로퍼티를 순회하며 프로퍼티가 객체 일 경우 재귀적으로 객체의 복사를 진행해야 한다. 자바스크립트 내장 함수로도 간단하게 처리하는 방법이 있는데, 이는 `JSON.parse(JSON.stringfy(object))`와 같이 함수를 호출하는 방식이다. 이는 객체를 JSON 문자열로 바꿨다가 이를 다시 객체로 바꾸는 방식으로 깊은 복사를 수행 할 수 있다.

>3. 함수 정의 방법들과 각 방법들의 차이점

  - 함수를 정의하는 방법으로는 **함수 선언문, 함수 표현식, 화살표 함수**의 방식이 자주 사용 된다. 
  **함수 선언문**의 경우 `funtion 식별자(){}`의 문법을 사용하는 방식으로, 런타임 이전에 함수가 생성되어, 함수 정의 전에 호출이 가능한 **함수 호이스팅**이 발생한다. 
  **함수 표현식**의 경우 `const 식별자 = funtion 식별자(){}`와 같이 함수 리터럴을 변수에 대입하는 식으로 정의되며, **함수 호이스팅이 아닌 변수 호이스팅**이 발생하여, 변수 같이 동작된다. 
  즉 const 또는 let으로 정의 된 변수에 대입된 함수는 변수와 마찬가지로 선언 전에 참조, 즉 호출 할 수 없다.
  **화살표 함수**의 경우 다른 함수들보다 짧은 구문을 활용할 수 있는 장점이 있으나 arguments 객체를 생성하지 않고, 자체 this 바인딩을 가지 않는 다는 특징이 있다. 또한 non-constructor로 생성자 함수로 호출 할 수 없다.

>4. function scope vs block scope

  - 함수 레벨 스코프는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성 되는 것을 의미하며, var로 변수를 선언 시 해당 변수는 함수 레벨 스코프를 따른다.
    블록 레벨 스코프는 let과 const로 변수를 선언시 함수를 포함한 모든 코드 블록에 의해 지역 스코프가 생성 되는 것을 의미한다.

>5. 프로토타입에 대한 설명

  - 자바스크립트는 프로토타입을 기반으로 상속을 구현하며, 프로토타입(객체)은 어떤 객체의 부모 객체 역할을 한다고 볼 수 있다.
  프로토타입은 생성자 함수(constructor)를 정의할 때 자동으로 생성되며, 어떤 객체의 프로퍼티에 접근하고자 할 때 각 객체의 프로토타입을 순차적으로 검색하며 해당 프로퍼티를 검색하게 된다. 이를 **프로토타입 체인**이라하며, 자바스크립트에서 상속을 구현하는 메커니즘의 핵심이라 볼 수 있다.
  좀 더 쉽게 설명하자면, 어떤 함수를 생성자 함수로서 호출하게 되면 생성 된 인스턴스는 해당 함수의 prototype 프로퍼티에 접근 할 수 있다. (접근자 프로퍼티인 __proto__로 접근이 가능) 이 prototype 프로퍼티는 객체이므로 개발자가 인스턴스에 필요로 하는 프로퍼티나 메서드를 지정할 수 있고, 이를 통해 상속을 구현할 수 있게 된다.  

  > 5.1 instaceof는 어떻게 동작하는가 

    - 해당 연산자는 `객체 instaceof 생성자함수` 와 같이 쓰이며, 이것이 의미하는 바는 **우변 생성자 함수의 프로토타입이 좌변 객체의 프로토타입 체인 내부에 존재하는가** 이다. 존재한다면 true, 존재하지 않는다면 false를 반환하게 된다.

>6. strict mode에 대해 설명

  - strict 모드는 개발과정에서 잠재적으로 발생할 수 있는 오류를 사전에 방지하기 위한 모드이다. 
  strict 모드를 통해서 사전에 검출 할 수 있는 에러로는 **식별자로 예약어 사용, 암묵적 전역, delete 연산자를 통한 변수/함수/매개변수 삭제, 매개변수 이름의 중복** 등이 있고 추가로 **this 바인딩과 arguments 객체의 동작에도 영향**을 준다.
  간단히 설명하자면 strict 모드에서는 식별자로 예약어를 사용하는 것이 금지되고, let이나 const 없이 변수를 선언하는 암묵적 전역 역시 금지된다. 또한 객체의 프로퍼티를 삭제할 때 사용되는 delete 연산자를 통한 변수/함수/매개변수의 삭제가 금지되고, 함수의 매개변수의 이름을 중복하여 선언하는 것 역시 금지 된다.
  추가로 함수를 일반함수로서 호출 시 this에는 전역 객체가 바인딩 되나 strict 모드에서는 undefined가 바인딩되고, 함수 내부에서 매개변수에 전달 된 인수를 재할당 할 경우 일반 모드와 달리 strict 모드에서는 arguments 객체 내부에 변경 된 인수의 값이 반영되지 않는다는 특징이 있다.