## React ; A Javascript library for building user interfaces

>1. 리액트 훅을 사용함에 있어 꼭 지켜야 할 점

  - 리액트 훅은 **컴포넌트 함수**나 **커스텀 훅** 내부에서만 호출되어야 한다.
  - 리액트 훅은 상기 함수의 top level에서만 호출되어야 한다. 즉, **내부의 다른 함수나 블록 내부에서 호출 할 수 없다.**

>2. useRef

  - 연결 된 태그의 실제 DOM Node를 저장 할 수 있음. 해당 노드의 값을 취득하거나 어트리뷰트를 취할때 유용

>3. useEffect

  - (함수형 컴포넌트) 컴포넌트가 마운트 될 때 컴포넌트의 내부 코드들에 대한 평가 이후 useEffect가 실행 된다.
  이후에는 의존성 배열 내부의 요소의 변경에 따라 실행되는데, 의존성 배열이 빈 배열로 주어진다면 마운트 될 시 한 번만 실행되고, 의존성 배열 자체를 생략한다면, 컴포넌트 재평가마다 useEffect도 같이 실행된다.

  - useEffect의 첫번째 인자로 주어지는 콜백함수 내부에서 다른 함수를 리턴할 수 있는데 이를 클린업 함수라 부른다. 
  클린업 함수는 useEffect가 실행되기 직전에 실행되는데(마운트 될 때 제외) 만약 의존성 배열이 빈 배열이라면 클린업 함수는 언마운트 시에만 실행 된다.

  - 특별한 이유가 없는한 useEffect 내부에서 참조하는 모든 항목은 의존성 배열에 추가되어야 한다.
  다만 브라우저에서 지원하는 API나 useState가 반환하는 state 업데이트 함수는 변하지 않으므로 추가하지 않아도 된다. 그러나 state 또는 props로 전달 된 데이터 등은 의존성 배열에 추가해야 한다.

>4. useCallback

  - useCallback은 컴포넌트의 함수를 저장할 때 사용하는 훅으로 컴포넌트가 재생성 될 때 해당 함수가 재생성되는 것을 막는 역할을 한다. 
  **useCallback 역시 useEffect와 마찬가지로 의존성 배열을 사용한다.**
  useCallback은 함수의 초기 상태 그대로 저장하기 때문에 내부의 함수가 state등의 변경 되는 값을 참조할 경우에도 초기값을 그대로 갖고 있게 된다. 따라서 조건부로 함수의 재생성이 필요하고 이를 위해 의존성 배열을 활용한다. 의존성 배열 내부에 있는 값이 변화될때에 한해 함수가 재생성 되는 것이다.

>5. useMemo

  - useMemo는 useCallback과 마찬가지로 객체의 값을 저장하기 위해 사용되는데 useCallback과의 차이점은 useCallback은 함수를 저장하고, useMemo는 함수를 포함한 다른 값들 역시 저장이 가능하다는 점이다.
  만약 어떤 배열 데이터가 컴포넌트 내부에서 정렬과정을 포함하는 로직을 가지고 있을때, 해당 데이터가 변경된 적이 없음에도 부모 컴포넌트의 재생성으로 인해 호출되는 것을 비효율적이다. 이럴 때 useMemo를 활용해서 정렬결과를 저장해놓고, 해당 배열이 바뀔 때만 새로운 결과 값을 받을 수 있도록 코드를 구성 할 수 있다. 

>5. Virtual DOM과 리액트의 작동방식

  - React는 컴포넌트를 통해 유저 인터페이스를 만든다. 그러나 실제 웹과 상호 작용하는 것은 ReactDOM으로 React는 props, state, context의 변화에 따른 컴포넌트의 변화를 ReactDOM에 알림으로써 DOM을 조작한다고 볼 수 있다.
  여기서 필요한 개념이 **가상 DOM**이다. React가 반환하는 JSX코드에 의해 가상 DOM이 만들어지고 ReactDOM은 이를 실제 DOM과 비교, 실제 DOM을 변경하게 된다. 그러나 주의 할 것은 `props, state, context의 변화에 따라 컴포넌트 함수가 재평가 된다는 것이 곧 DOM의 리렌더링을 의미하는 것은 아니다.`
  실제 DOM은 리액트 컴포넌트 트리의 이전상태와 현재 DOM의 차이점을 평가하여 변경이 필요한 경우에만 업데이트 된다. 
  즉 이 가상 DOM을 통해 필요한 부분만 비교해서 변경함으로써 성능상의 이득을 가져올 수 있다.

  - 반대로 특정 컴포넌트 함수가 재평가 될 때 해당 컴포넌트의 자식 컴포넌트는 어떻게 될까?
  컴포넌트는 결국 함수이므로 부모 컴포넌트가 재평가(재실행) 된다면 비록 자식 컴포넌트 내부에서 변하는 것이 없더라도 자식 컴포넌트 역시 재실행 된다.
  만약 props가 없거나 props의 변화가 없음에도 자식 컴포넌트가 재실행 되는 것을 막고 싶다면 React.memo 기능을 사용하면 된다.
  단 React.memo는 함수형 컴포넌트에만 적용이 가능하다. 그렇다면 모든 컴포넌트에 React.memo를 쓰면 되지않겠냐는 의문이 들 수 있는데, React.memo 자체도 props의 변경을 추적하기 위해 비교 과정이 필요하므로 별도의 성능을 소모하게 된다. 따라서 컴포넌트 트리가 매우 커서 자식 컴포넌트가 많은 경우가 아니라면, 모든 컴포넌트에 React.memo를 사용하는 것이 더 비효율적일 수 있다.

  - 추가로 생각해볼 문제는 React의 컴포넌트가 재실행 될 때 함수 등 내부의 객체 형태의 데이터들은 어떻게 되는가?
  컴포넌트가 재실행 되면 내부의 데이터들은 모두 재생성 된다고 볼 수 있는데 문제는 자바스크립트의 원시 값이 아닌 참조 값인 객체들은 재생성 시 이전과 다른 객체로 취급이 된다. 따라서 자식 컴포넌트에 React.memo를 사용했다하더라도 전달 된 props가 객체 형태의 자료라면 리액트에서는 해당 props가 변경되었다고 인식하게 된다. 이럴 때 위에서 설명한 useCallback, useMemo를 사용할 수 있다.