## JavaScript 나올 만한 질문들

순서는 중요도와 관계 없음

>1. let과 const가 도입 된 이유 (var, let, const 차이)

  - 기존(ES5까지)에는 var 키워드를 사용하여 변수를 선언했으나, var 키워드를 사용할 경우 **변수의 중복선언 가능, 함수 레벨 스코프 지원, 변수 호이스팅**의 문제가 있다. 
  여기서 **변수의 중복 선언**은 말 그대로 이미 선언된 변수가 있음에도 동일한 식별자를 가지는 변수를 선언할 수 있음을 의미하고 이는 네임스페이스 오염의 문제가 있다.
  **함수 레벨 스코프**는 var로 선언 된 변수는 함수의 코드 블록 {} 만을 지역 스코프로 인정하는 것을 의미한다. 즉, if문, for문 등의 코드 블록 내부에서 변수를 선언할 경우 이는 모두 전역 변수가 된다.
  **변수 호이스팅**은 var로 선언된 변수는 런타임 이전에 소스 코드 평가 과정에서 undefined로 초기화 되므로 변수 선언 이전에 참조가 가능한 현상을 말한다. 
  이러한 문제를 해결하기 위해 ES6부터 let과 const가 도입되었고, let과 const는 변수의 중복 선언을 막고, 블록 레벨 스코프를 지원하며, 런타임에 변수의 초기화가 이루어지므로 변수 호이스팅이 발생하지 않는 것 처럼 동작된다는 장점이 있다. (참고로 호이스팅이 발생하지 않는 것은 아니다.)

>2. 깊은 복사와 얕은 복사에 대한 설명

  - 객체를 프로퍼티로 갖는 객체, 즉 중첩 객체를 복사할 때 한 단계만 복사 되는 것을 얕은 복사, 내부의 중첩 객체까지 모두 복사 되는 것을 깊은 복사라 한다.
  깊은 복사를 위해서는 객체의 내부 프로퍼티를 순회하며 프로퍼티가 객체 일 경우 재귀적으로 객체의 복사를 진행해야 한다. 자바스크립트 내장 함수로도 간단하게 처리하는 방법이 있는데, 이는 `JSON.parse(JSON.stringfy(object))`와 같이 함수를 호출하는 방식이다. 이는 객체를 JSON 문자열로 바꿨다가 이를 다시 객체로 바꾸는 방식으로 깊은 복사를 수행 할 수 있다.

>3. 함수 정의 방법들과 각 방법들의 차이점

  - 함수를 정의하는 방법으로는 **함수 선언문, 함수 표현식, 화살표 함수**의 방식이 자주 사용 된다. 
  **함수 선언문**의 경우 `funtion 식별자(){}`의 문법을 사용하는 방식으로, 런타임 이전에 함수가 생성되어, 함수 정의 전에 호출이 가능한 **함수 호이스팅**이 발생한다. 
  **함수 표현식**의 경우 `const 식별자 = funtion 식별자(){}`와 같이 함수 리터럴을 변수에 대입하는 식으로 정의되며, **함수 호이스팅이 아닌 변수 호이스팅**이 발생하여, 변수 같이 동작된다. 
  즉 const 또는 let으로 정의 된 변수에 대입된 함수는 변수와 마찬가지로 선언 전에 참조, 즉 호출 할 수 없다.
  **화살표 함수**의 경우 다른 함수들보다 짧은 구문을 활용할 수 있는 장점이 있으나 arguments 객체를 생성하지 않고, 자체 this 바인딩을 가지 않는 다는 특징이 있다. 또한 non-constructor로 생성자 함수로 호출 할 수 없다.

>4. function scope vs block scope

  - 함수 레벨 스코프는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성 되는 것을 의미하며, var로 변수를 선언 시 해당 변수는 함수 레벨 스코프를 따른다.
    블록 레벨 스코프는 let과 const로 변수를 선언시 함수를 포함한 모든 코드 블록에 의해 지역 스코프가 생성 되는 것을 의미한다.

>5. 프로토타입에 대한 설명

  - 자바스크립트는 프로토타입을 기반으로 상속을 구현하며, 프로토타입(객체)은 어떤 객체의 부모 객체 역할을 한다고 볼 수 있다.
  프로토타입은 생성자 함수(constructor)를 정의할 때 자동으로 생성되며, 어떤 객체의 프로퍼티에 접근하고자 할 때 각 객체의 프로토타입을 순차적으로 검색하며 해당 프로퍼티를 검색하게 된다. 이를 **프로토타입 체인**이라하며, 자바스크립트에서 상속을 구현하는 메커니즘의 핵심이라 볼 수 있다.