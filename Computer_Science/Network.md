## 네트워크 관련 질문들

순서는 중요도와 관계 없음

>1. protocol이란?

  - 프로토콜은 규약을 의미하는 단어로 쉽게 말해 통신을 하기 위한 규칙이라고 볼 수 있다. 대표적으로 TCP/IP를 들 수 있다.

>2. OSI 7계층과 TCP/IP 4계층을 비교/설명

  - **OSI 모델**은 네트워크 기술의 기본이 되는 모델로, 통신 시스템을 응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리 계층의 7계층으로 나누어 설명한 것이다. 
  **TCP/IP** 모델은 OSI 7계층을 4계층으로 단순화 한 모델로 응용, 전송, 인터넷, 네트워크 접속 계층으로 구분된다. 
  데이터를 전송 할 떼 데이터를 전송하는 쪽은 데이터를 상위 계층에서 하위 계층으로, 수신 측은 데이터를 하위 계층에서 상위 계층으로 전달한다. 이 때 각 계층에서는 데이터 외에 통신 프로토콜의 특성을 포함한 정보를 Header에 포함 시켜서 하위 계층에 전송을 하게 되는데 이를 **캡슐화**라 부른다. 반대로 수신측에서 하위 계층에서 상위 계층으로 데이터를 전송하면서 이러한 Header를 제거하는데 이를 **역캡슐화**라 부른다.

>3. TCP vs UDP 비교 설명

  - **TCP(Transmission Control Protocol)**는 연결형 전송 프로토콜로 신뢰성과 정확성을 우선으로 한다. TCP는 데이터 전송 전에 **3-way handshake**를 통해 전송 계층간 논리적 연결을 설립한다. 또한 데이터를 보냄에 있어서도 데이터의 중복이나 손실없이 순서에 맞게 보내기 위해 재전송제어/오류제어/흐름제어/혼잡제어등이 적용 된다. **효율성은 떨어지는 대신 신뢰성이 보장되므로 문서 등 훼손되면 안되는 파일의 전송 등에 활용** 된다.
  **UDP(USer Datagram Protocol)**는 비연결형 전송 프로토콜로 효율성을 우선으로 한다. UDP는 TCP와 달리 데이터 전송을 위한 별도의 확인 과정이 없고, 또한 흐름제어/오류제어 등을 제공하지 않아 TCP에 비해 오버헤드가 적다. 따라서 **정확한 데이터 전송보다도 빠른 데이터 전송이 필요한 동영상 스트리밍 서비스 등에 활용** 된다. 

  >3-1. 3-way handshake에 대한 추가 설명

    - 데이터를 보내기 전 연결 확립을 위해 패킷 요청을 세번 교환 하는 것을 말한다. 
    먼저 클라이언트가 서버에 연결 확립 허가를 위해 헤더에 **연결 확립 요청(SYN 패킷)**을 보내면, 서버는 이를 확인하고 **연결 확립 응답(ACK 패킷)**과 같이 **연결 확립 요청(SYN 패킷)**을 다시 보내고, 다시 클라이언트가 이에 **연결 확립 응답(ACK 패킷)**을 보냄으로써 연결이 이루어진다. 
    참고로 연결 해제시에는 4-way handshake을 통해 연결이 해제 된다.

>4. HTTP에 대한 설명

  - HTTP(Hyper Text Transfer Protocol)는 OSI모델의 응용계층에서 사용되는 프로토콜로 request/response 구조로 웹상에서 정보를 주고 받을 수 있는 프로토콜이다.
  HTTP의 특징으로는 Connetionless와 Stateless를 들 수 있다. 먼저 **Connetionless**는 서버에 요청이후 응답을 받으면 연결을 끊어버리는 특성으로 동시 접속을 최소화하여 리소스를 줄일 수 있다. 그러나 동일한 클라이언트의 재요청에 대해 매번 연결을 다시해야되다보니 이로인한 오버헤드가 존재하는 단점이 있고, 이를 해결하기 위해 keepalive 기능이 사용된다.
  **Stateless**는 Connetionless로 인해 클라이언트의 이전상태를 알 수 없다는 특성을 말하는 것이다. 이로 인해 서버는 클라이언트가 로그인 상태인지 아닌지 등을 파악할 수 없으므로 이러한 문제를 해결하기 위해 cookie, session, jwt등이 도입되었다. 

  >4-1. HTTP method (GET, POST, PUT, PATCH)에 대한 비교 설명
    - 먼저 GET과 POST를 비교해보면, **GET**은 클라이언트가 서버에서 정보를 요청할 때 사용하는 메서드로 필요한 정보를 URL 주소 끝에 쿼리스트링 형태로 요청하게 된다. 즉 요청 내용에 대해 URL과 함께 브라우저 히스토리에 저장되므로 캐시가 가능한 특징이 있다.
    **POST**의 경우 클라이언트가 서버에 데이터 처리를 요청할 때 사용하는 메서드로 필요한 정보는 body를 통해 전달하게 된다. 따라서 요청 내용에 대해 히스토리가 남지 않아 캐시를 할 수 없고 또한 GET과 달리 단순히 데이터를 요청하는것 외에 데이터 생성, 변경 할 때도 사용할 수 있다.
    **PUT**의 경우 어떤 리소스를 서버에 저장할 때 사용되는데 기존에 있던 리소스를 통째로 교체하거나, 기존에 리소스가 없다면 새로 생성하게 된다.
    **PATCH**의 경우 이와 달리 기존에 있던 리소스를 통째로 교체하는 것이 아닌, 변경부분만 수정하게 된다. 즉 리소스의 전체를 업데이트하는지(PUT), 일부만 업데이트 하는지(PATCH)의 차이라고 볼 수 있다.

>5. 인증(authentication) vs 인가(authorization)

  - **인증**은 로그인을 생각하면 된다. 서비스에 권한이 있는 사용자임을 인증 받는 것을 말한다. **인가**는 인증받은 사용자가 요청하는 것에 대한 권한이 있는지 확인하는 절차로 해당 계정에서만 사용할 수 있는 서비스에 접근할 때 필요하다고 볼 수 있다. 즉 `사용자가 누구인지 확인할 때는 인증, 확인 된 사용자가 특정 기능을 사용해도 되는지 확인할 때는 인가`라고 보면 된다.

  >5-1. 쿠키와 세션을 통한 인가

  - 클라이언트가 인증에 성공하면 서버는 session ID를 클라이언트에게 발급한다. 클라이언트는 이를 쿠키에 저장하고 이후 브라우저는 요청을 보낼 때 마다 이를 헤더에 실어 보내게 된다. 그러면 서버는 이 session ID를 서버측 세션 저장소의 클라이언트 정보와 대조, 인가를 진행하게 된다. 그러나 session ID를 통한 인증 방식은 에러등으로 인한 서버를 재시작해야 되는 경우 데이터가 모두 날아가게 되는 문제가 있고 또한 여러 서버를 사용하는 서비스 등에서는 구현하기 힘든 문제가 있는등 단점이 있다. 

  >5-2. JWT 방식?

  - JSON Web Token의 줄임말로 클라이언트가 인증에 성공하면 Token을 송부하는 방식으로, 세션방식과 달리 서버에는 관련 정보를 저장하지 않는다. 이 토큰에는 인가에 필요한 데이터가 담겨 있고, 클라이언트가 요청시 이 토큰을 보내면 서버는 이를 서버의 비밀키를 통해 특정 알고리즘을 사용해 토큰의 서명을 확인한다. 서버는 사용자들의 상태를 저장할 필요가 없으므로 세션과 달리 stateless한 방식이다. 
  그러나 세션을 대체하기에는 JWT 역시 단점이 존재하는데, 세션과 달리 토큰은 한번 사용자에게 전달되고 나면 그 정보를 수정할 수 가 없다. 따라서 토큰의 탈취 등의 문제가 생겼을 때 서버측에서 이를 막을 방법이 없게 되는 등 단점이 존재한다.
  이를 개선하기 위한 방법으로 access 토큰과 refresh 토큰을 활용하는 방법이 있다.

  >5-3. access 토큰과 refresh 토큰을 활용(참고 사항)

  - JWT 방식의 문제점을 개선하기 위한 방법으로 유효기간이 짧은 access 토큰과 유효기간이 긴 refresh 토큰 두 가지를 활용하는 방법이다.
  refresh 토큰은 서버에서 상응값을 데이터베이스에 저장, 사용자의 access 토큰의 유효기간이 만료되면 사용자가 refresh 토큰을 서버에 보내고 서버는 이를 데이터 베이스의 값과 대조 후, 다시 access 토큰을 발행한다. 
  인가는 access 토큰을 통해 진행되고, 재발급 시에만 refresh 토큰을 사용함에 따라 access 토큰이 탈취될 시 refresh 토큰을 삭제하는 방식으로 토큰의 재발행을 막을 수 있다.
